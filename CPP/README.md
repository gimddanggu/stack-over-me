### 메모리 구조 정리
변수의 종류에 따라 메모리 상의 위치가 달라지며, 이는 **변수의 생명주기**와 **스레드 간 공유 여부**에 영향을 미친다.
예를 들어, 지역 변수는 스택(Stack)에 저장되어 함수 실행 중에만 존재하고,
전역 변수와 static 변수는 데이터(Data) 영역에 위치하여 프로그램 전체 실행 시간 동안 유지된다.

또한, 스레드를 사용할 경우 전역 변수나 static 변수는 **모든 스레드가 공유**하지만,
스택에 저장된 지역 변수는 **각 스레드마다 별도로 존재**한다.

프로그래밍에서 변수의 생존 기간과 메모리 상 위치를 이해하는 것은 효율적인 코드 작성과 디버깅에 매우 중요하다.
이를 위해 다음과 같은 메모리 구조를 이해해야 한다:
```
   ↓ 낮은 주소
+--------------------+
|   Code 영역        |  ← 기계어 명령 (함수 등)
+--------------------+
|   Data 영역        |  ← 초기화된 전역/정적 변수
|   BSS 영역         |  ← 초기화되지 않은 전역/정적 변수
+--------------------+
|   Heap 영역        |  ← 동적 할당 메모리 (new/malloc)
|                    |  ← 위쪽으로 확장
+--------------------+
|   Stack 영역       |  ← 함수 호출 시 지역변수 등
|                    |  ← 아래쪽으로 확장
+--------------------+
   ↑ 높은 주소
```
# 나중에 정리!
각각의 영역에는 어떤 특징이 있는지 알아보자
Code 영역
컴파일된 프로그램의 기계어 명렁어가 저장된다(함수, 루프 등)
- 특징
    - 읽기 전용
    -
Data 영역
BSS 영역
Heap 영역
Stack 영역

정적 다형성
- template
- 
동적 다형성
- virtual 
- 오버로딩


> 궁금증1: 인자로 const char* 은 많이 사용하는데 const int는 사용안하나?
C++ 함수 인자 전달 방식
- `int` 같은 기본형은 값으로 전달 -> 복사본으로 전달됨
- `char*` 같은 **포인터/배열/객체**는 주소(참조)에 가까운 개념으로 전달됨 -> **원본 바꿀 수 있음**

기본형으로 받은 변수는 복사되어서 들어오기 때문에 외부의 값일 바뀔 위험이 없다 -> `const` 안 붙여도 안전
하지만 `char*` 은 **포인터** 이기 때문에 원본 수정 가능성이 있다!!!
그렇기 때문에 값 수정이 없으면 `const` 키워드를 붙여 실수를 줄이고 의미도 명확하게 하자는 의도

**멤버변수**는 객체대 객체로 복사됨
**멤버함수**는 복사안됨 메모리에서 공유함(코드 영역) - 그럼 인라인은?
> 궁금증2: 인라인은 값이 복사되는 거 아닌가?

인라인 함수는 **객체가 아니라 코드에 "삽입"되는 컴파일러 최적화 기법*이다
함수 코드가 객체에 딸려온다는 뜻이 아니다!!!!


> 궁금증3: 그럼 멤버함수는 객체마다 복사되지 않고 공유되는거면 static 함수랑 똑같은 거 아닌가?

공유된다는 점에서는 비슷하지만, 개념은 다르다.
공통점: 객체가 여러 개여도 함수는 하나만 존재
차이점: 
   - 호출방식
   - 어떤 데이터에서 접근 가능하냐


| 구분               | 일반 멤버함수 (`void foo()`) | `static` 멤버함수 (`static void foo()`) |
| ---------------- | ---------------------- | ----------------------------------- |
| 객체 필요 여부         | ✅ 필요 (객체가 있어야 호출 가능)   | ❌ 불필요 (클래스명으로 직접 호출 가능)             |
| `this` 포인터 존재 여부 | ✅ 존재                   | ❌ 없음                                |
| 멤버 변수 접근         | ✅ 가능 (`this->x` 등)     | ❌ 불가능 (정적 멤버만 접근 가능)                |
| 호출 방법            | `obj.foo();`           | `ClassName::foo();` 또는 `obj.foo();` |

> 궁금증4: 그럼 static 함수는 객체 생성 없이도 사용 가능한데 클래스 밖에서 선언하면 되는 거 아닌가?

클래스 안에 있는 static 함수와 클래스 밖에 있는 static 함수는 목적이 다름!!!!

클래스 안의 static 함수의 목적
- 클래스에 소속된 정적 함수
- 객체 없이 사용 가능
- 클래스 관련 기능을 **객체 없이 묶어두기** 위한 용도
- `this` 포인터 없음 -> 인스턴스 멤버 접근 불가
- 오버로딩,. 템플릿, 접근제어 등 클래스 문법의 영향을 받음

클래스 밖의 static 함수 (전역 static 함수)
- **링크 범위를 제한**하는 static(파일 내부에서만 사용 가능)
   - 외부 파일에서 이 함수는 안 보인다!! (파일 스코프)
- C 스타일 모듈화를 위한 방식 (이 말은 잘 이해가 안됨..다시 찾아보기)
- 컴파일 단위 내의 캡슐화 역할

전역 함수
- 클래스 밖에서 선언
- 기본적으로 전역 네임스페이스에 존재 (오염위험 있음)

> 🧠 클래스 안의 static은 OOP, 클래스 밖의 static은 캡슐화 용도

> 궁금증5: `static`은 보통 heap영역에 저장되는데 그럼 `static` 함수도 heap 영역에 저장되는건가?

X. 함수는 무조건 CODE 영역에 저장됨
`static`에 따라 저장 영역이 달라지는 건 변수!!


> 궁금증6: 복사 생성자에서 &를 붙이는 이유: 이미 객체 한번 생성했는데 그걸 써서 생성하는거아닌가?

그냥 생성자와 다르게 복사 생성자라는 개념이 따로 있음 복사할 때 생성되는 생성자
```
Person(const Person other) { }  // 👈 값으로 받음 → 복사 발생

Person p1;        // 기본 생성자 호출
Person p2 = p1;   // 여기서 복사 생성자 호출

// p1 → p2를 만들기 위해 Person(const Person other) 호출
// 그런데 매개변수 other 자체도 복사 필요
// 그래서 다시 복사 생성자 호출 → 무한 반복 → 컴파일러 오류
```
> 궁금증 7: 깊은복사 왜 필요함?

기본 복사는 얕은 복사(shallow copy)로, 포인터 값만 복사된다.
이 경우, 복사된 객체와 원본 객체가 같은 **heap 메모리를 공유**하게 된다.
하나의 객체가 소멸되면 해당 메모리를 해제하게 되며,
**나머지 객체는 해제된 주소를 참조하게 되어 잘못된 동작이 발생할 수 있다.**
이를 방지하기 위해, **포인터가 가리키는 실제 데이터를 복사하는 깊은 복사(deep copy)가 필요**하다.

> 궁금증 8: 얘는 왜 안될까? 배열도 포인터 아닌가?
```cpp
char* mname;
char mname[10]; // 궁금증8:왜 얘는 안될까?

mname = new char[strlen(name) + 1];
```
(1) char* mname 포인터일 경우 new 로 동적 메모리 할당이 가능하다.
(2) char mname[10] (배열)일 경우 복사 생성자에서 문제가 발생한다

이유:
- 배열은 컴파일 시 크기가 고정된 메모리이기 때문이다.
- new 연산자를 사용해 재할당이 불가능하다.
- 즉, 배열은 대입 불가, 포인터는 대입 가능

이러한 이유 때문에 복사 생성자에서 더 큰 차이가 발생한다.
```
Person(const Person& other) {
    mname = new char[strlen(other.mname) + 1];   // 포인터니까 new 가능
    strcpy(mname, other.mname);                  // 문자열 복사
}
```
mname 이 배열이었다고 가정을 해보면
1. mname은 고정된 크기이기 때문에 다른 크기로 새롭게 할당할 수 없다.
2. `mname = other.mname` 과 같은 대입 연산도 불가능하다 (배열은 통째로 복사가 불가능하기 때문이다.)
3. `strcpy(mname, other.mname)` 는 가능할 순 있지만, **정해진 크기 때문에 용량 초과의 위험이 있다**

**🧠💡따라서 deep copy 를 하려면  유연한 메모리 공간이 필요하기 때문에 포인터를 사용해야 한다!**
`~Person()` 안에서 `delete[] mname` 해줘야 메모리 누수가 없다는 것도 기억해두기!

> 궁금증 9: `delete` 에서 [] 는 배열일 때만 붙이는 건가?

`delete` 와 `delete[]` 는 용도가 다르다
일반객체인 경우
```
int* p = new int(42);  // 하나의 정수
delete p;       
```
- 하나의 객체만 삭제
배열 객체인 경우
```
int* arr = new int[10];   // 정수 10개짜리 배열
delete[] arr;             
```
- delete arr 만 쓰면 -> 정의되지 않은 동작(UB) 오류 발생
- 클래스 타입일 때 소멸자가 일부만 호출되는 문제 발생됨

C++은 내부적으로 `new` 와 `new[]` 에 대해 **다른 메모리 관리 전략을 사용**한다.
new[]는 **배열의 요소 개수를 기억**하고, **소멸자 호출도 반복**한다.
이 정보를 바탕으로 delete[]는 **배열 전체**의 소멸자를 호출한다. 
